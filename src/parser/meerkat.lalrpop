// L1 Compiler
//! Parser Grammar
// Author: Miles Conn <mconn@andrew.cmu.edu>

// Initial grammar for L1 

// Grammar 
grammar<'input>;

use crate::ast::{ReplCmd, Prog, Service, Decl, Assn, Expr, UnOp, BinOp, Test, DataType, Field, Insert, Entry, Row};
use lalrpop_util::ParseError;
use crate::parser::lex::Token;

use std::str::FromStr;

extern {
    type Location = usize;
    type Error = String;

    enum Token<'input> {
        "service" => Token::SERVICE,
        "@test" => Token::TEST_KW,
        "do" => Token::DO_KW,
        "assert" => Token::ASSERT_KW,
        "import" => Token::IMPORT_KW,
        "var" => Token::VAR_KW,
        "pub" => Token::PUB_KW,
        "def" => Token::DEF_KW,
        "table" => Token::TABLE_KW,
        "insert" => Token::INSERT_KW,
        "select" => Token::SELECT_KW,
        "from" => Token::FROM_KW,
        "where" => Token::WHERE_KW,
        "into" => Token::INTO_KW,
        "action" => Token::ACTION_KW,
        "fn" => Token::FN_KW,
        "then" => Token::THEN_KW,
        "if" => Token::IF_KW,
        "else" => Token::ELSE_KW,
        "number" => Token::NUMBER_KW,
        "string" => Token::STRING_KW,
        "bool" => Token::BOOL_KW,
        ";" => Token::Semicolon,
        "." => Token::Dot,
        "=" => Token::Assgn,
        "=>" => Token::Fn_Assgn,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Div,
        "==" => Token::EQ_EQ,
        "<" => Token::LT,
        ">" => Token::GT,
        "&&" => Token::AND_AND,
        "||" => Token::OR_OR,
        "!" => Token::NOT_NOT,

        
        
        "strlit" => Token::StrLit(<&'input str>),
        "ident" => Token::Ident(<&'input str>),
        "num" => Token::Number(<i32>),
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LSquare,
        "]" => Token::RSquare,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "," => Token::Comma,
        ":" => Token::Colon,
        "true" => Token::TRUE,
        "false" => Token::FALSE,
    }
}

pub Prog: Prog = {
    <services: Services> <tests: Tests> => Prog { services, tests }
}   

Service: Service = {
    "service" <i:Ident> "{" <ds:Decls> "}" => {
        Service { name: i, decls: ds }
    },
}

Services: Vec<Service> = {
    => vec![],
    <mut v:Services> <s:Service> => {
        v.push(s);
        v
    }
}

Test: Test = {
    "@test" "(" <i:Ident> ")" "{" <cms: ReplCmds> "}" => {
        Test { name: i, commands: cms }
    },
}

Tests: Vec<Test> = {
    => vec![],
    <mut v:Tests> <t:Test> => {
        v.push(t);
        v
    }
}

ReplCmd: ReplCmd = {
    "do" <e: Expr> ";" => {
        ReplCmd::Do(e)
    },
    "assert" "(" <e:Expr> ")" ";" => {
        ReplCmd::Assert(e)
    },
}

ReplCmds: Vec<ReplCmd> = {
    => vec![],
    <mut v:ReplCmds> <c:ReplCmd> => {
        v.push(c);
        v
    }
}

Decl: Decl = {
    "import" <i:Ident> ";" => {
        Decl::Import { srv_name: i }
    },
    "var" <i:Ident> "=" <e:Expr> ";" => {
        Decl::VarDecl { name: i, val: e }
    },
    "pub" "def" <i:Ident> "=" <e:Expr> ";" => {
        Decl::DefDecl { name: i, val: e, is_pub: true }
    },
    "def" <i:Ident> "=" <e:Expr> ";" => {
        Decl::DefDecl { name: i, val: e, is_pub: false }
    },
    "table" <i:Ident> "{" <f: Fields> "}" ";" => {
        Decl::TableDecl {name: i, fields: f }
    }
}

Decls: Vec<Decl> = Decl*;

Field: Field = {
   <i:Ident> ":" <t: DataType> "," => {
    Field {name: i, type_: t}
   } 
}

Fields: Vec<Field> = Field*;

DataType: DataType = {
    "number" => DataType::Number,
    "string" => DataType::String,
    "bool" => DataType::Bool,
}

Entry: Entry = {
    <c: Ident> ":" <e: Expr>  => {
        Entry {name: c, val: e }
    }
}

Row: Row = {
     "{" <mut entries:(<Entry>",")*> <e:Entry?> "}" => Row {
        val: {
            let mut v = entries;
            if let Some(entry) = e {
                v.push(entry);
            }
            v
        }
    }
}

Insert: Insert = {
    "insert"  <e: Expr> "into" <t: Ident> => {
        Insert {row: e, table_name: t}
    }
}

Inserts: Vec<Insert> = Insert*;

Assn: Assn = {
    <i:Ident> "=" <e:Expr> ";" => Assn { dest: i, src: e }
}

Assns: Vec<Assn> = {
    => vec![],
    <mut v:Assns> <a:Assn> => {
        v.push(a);
        v
    }
}

Params: Vec<String> = {
    <mut v:(<Ident> ",")*> <e:Ident?> => 
    match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Args: Vec<Expr> = {
    <mut v:(<Expr> ",")*> <e:Expr?> => 
    match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}



SubExpr: Expr = {
    <n:Number> => Expr::Number { val: n },
    <b:Bool> => Expr::Bool { val: b },
    <s: "strlit"> => Expr::String {val: s.to_owned()},
    <i:Ident> => Expr::Variable { ident: i },
    "(" <Expr> ")" => <>,
    "[" <mut rows: (<Row> ",")*> <r: Row?> "]" => {
        if let Some(row) = r {
            rows.push(row);
        }
        Expr::Rows { val: rows }
    },
    <r: Row> => Expr::Rows {val: vec![r]},
    
    <expr:SubExpr> "(" <args:Args> ")" => 
        Expr::FuncApply { func: Box::new(expr), args },

    

    "action" "{" <assns: Assns><inserts: Inserts> "}" => Expr::Action { assns, inserts },
     <t:Ident> "." <c:Ident> => {
        Expr::TableColumn {
            table_name: t,
            column_name: c
        }
    },
    
    
}

Expr: Expr = {
    #[precedence(level="0")]
    SubExpr => <>,

    #[precedence(level="1")] #[assoc(side="right")]
    "-" <e:Expr> => {
        Expr::Unop { expr: Box::new(e), op: UnOp::Neg }
    },
    "!" <e:Expr> => {
        Expr::Unop { expr: Box::new(e), op: UnOp::Not }
    },
    
    

    #[precedence(level="2")] #[assoc(side="left")]
    <e1:Expr> "*" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::Mul 
        }
    },
    <e1:Expr> "/" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::Div 
        }
    },
    

    #[precedence(level="3")] #[assoc(side="left")]
    <e1:Expr> "+" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::Add 
        }
    },
    <e1:Expr> "-" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::Sub 
        }
    },
   

    #[precedence(level="4")] #[assoc(side="left")]
    <e1:Expr> "==" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::Eq 
        }
    },
    <e1:Expr> "<" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::Lt 
        }
    },
    <e1:Expr> ">" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::Gt 
        }
    },

    #[precedence(level="5")] #[assoc(side="left")]
    <e1:Expr> "&&" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::And 
        }
    },
   

    #[precedence(level="6")] #[assoc(side="left")]
    <e1:Expr> "||" <e2:Expr> => {
        Expr::Binop { 
            expr1: Box::new(e1), 
            expr2: Box::new(e2), 
            op: BinOp::Or 
        }
    },

    #[precedence(level="7")] #[assoc(side="left")]
    "if" <e1:Expr> "then" <e2:Expr> "else" <e3:Expr> => {
        Expr::If { 
            cond: Box::new(e1),
            expr1: Box::new(e2), 
            expr2: Box::new(e3), 
        }    
    },

    #[precedence(level="8")] #[assoc(side="left")]
    "fn" <params:Params> "=>" <e:Expr> => 
    Expr::Func {
        params, body: Box::new(e)
    },
    "select" <mut cols: (<Ident> ",")*> <c: Ident?> "from" <t: Ident> "where" <cond: Expr> => Expr::Select {
        table_name: t,
        column_names: {
            let mut v = cols;
            if let Some(col) = c { 
                v.push(col); }
            v
        },
        where_clause: Box::new(cond)
    },
}

Bool: bool = {
    "true" => true,
    "false" => false, 
}

Number: i32 = {
    <n:"num"> => n
}

Ident: String = {
    <i:"ident"> => i.to_owned()
}